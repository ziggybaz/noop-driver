{"$message_type":"diagnostic","message":"unresolved import `tokio`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":17,"byte_end":22,"line_start":3,"line_end":3,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use tokio;","highlight_start":5,"highlight_end":10}],"label":"no external crate `tokio`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `tokio`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse tokio;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno external crate `tokio`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected value, found trait `ReadOperations`","code":{"code":"E0423","explanation":"An identifier was used like a function name or a value was expected and the\nidentifier exists but it belongs to a different namespace.\n\nErroneous code example:\n\n```compile_fail,E0423\nstruct Foo { a: bool };\n\nlet f = Foo();\n// error: expected function, tuple struct or tuple variant, found `Foo`\n// `Foo` is a struct name, but this expression uses it like a function name\n```\n\nPlease verify you didn't misspell the name of what you actually wanted to use\nhere. Example:\n\n```\nfn Foo() -> u32 { 0 }\n\nlet f = Foo(); // ok!\n```\n\nIt is common to forget the trailing `!` on macro invocations, which would also\nyield this error:\n\n```compile_fail,E0423\nprintln(\"\");\n// error: expected function, tuple struct or tuple variant,\n// found macro `println`\n// did you mean `println!(...)`? (notice the trailing `!`)\n```\n\nAnother case where this error is emitted is when a value is expected, but\nsomething else is found:\n\n```compile_fail,E0423\npub mod a {\n    pub const I: i32 = 1;\n}\n\nfn h1() -> i32 {\n    a.I\n    //~^ ERROR expected value, found module `a`\n    // did you mean `a::I`?\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":160,"byte_end":174,"line_start":7,"line_end":7,"column_start":33,"column_end":47,"is_primary":true,"text":[{"text":"    let read_process = Box::new(ReadOperations);","highlight_start":33,"highlight_end":47}],"label":"not a value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0423]\u001b[0m\u001b[0m\u001b[1m: expected value, found trait `ReadOperations`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:33\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let read_process = Box::new(ReadOperations);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected value, found trait `WriteOperations`","code":{"code":"E0423","explanation":"An identifier was used like a function name or a value was expected and the\nidentifier exists but it belongs to a different namespace.\n\nErroneous code example:\n\n```compile_fail,E0423\nstruct Foo { a: bool };\n\nlet f = Foo();\n// error: expected function, tuple struct or tuple variant, found `Foo`\n// `Foo` is a struct name, but this expression uses it like a function name\n```\n\nPlease verify you didn't misspell the name of what you actually wanted to use\nhere. Example:\n\n```\nfn Foo() -> u32 { 0 }\n\nlet f = Foo(); // ok!\n```\n\nIt is common to forget the trailing `!` on macro invocations, which would also\nyield this error:\n\n```compile_fail,E0423\nprintln(\"\");\n// error: expected function, tuple struct or tuple variant,\n// found macro `println`\n// did you mean `println!(...)`? (notice the trailing `!`)\n```\n\nAnother case where this error is emitted is when a value is expected, but\nsomething else is found:\n\n```compile_fail,E0423\npub mod a {\n    pub const I: i32 = 1;\n}\n\nfn h1() -> i32 {\n    a.I\n    //~^ ERROR expected value, found module `a`\n    // did you mean `a::I`?\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":210,"byte_end":225,"line_start":8,"line_end":8,"column_start":34,"column_end":49,"is_primary":true,"text":[{"text":"    let write_process = Box::new(WriteOperations);","highlight_start":34,"highlight_end":49}],"label":"not a value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0423]\u001b[0m\u001b[0m\u001b[1m: expected value, found trait `WriteOperations`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:8:34\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let write_process = Box::new(WriteOperations);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::error::Error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/driver.rs","byte_start":4,"byte_end":21,"line_start":1,"line_end":1,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/driver.rs","byte_start":0,"byte_end":23,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::error::Error`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::error::Error;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated function `new` is private","code":{"code":"E0624","explanation":"A private item was used outside of its scope.\n\nErroneous code example:\n\n```compile_fail,E0624\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // error: method `method` is private\n```\n\nTwo possibilities are available to solve this issue:\n\n1. Only use the item in the scope it has been defined:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n\n    pub fn call_method(foo: &Foo) { // We create a public function.\n        foo.method(); // Which calls the item.\n    }\n}\n\nlet foo = inner::Foo;\ninner::call_method(&foo); // And since the function is public, we can call the\n                          // method through it.\n```\n\n2. Make the item public:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        pub fn method(&self) {} // It's now public.\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // Ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":267,"byte_end":270,"line_start":10,"line_end":10,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"    let mut driver = DriverProcesses::new(read_process, write_process);","highlight_start":39,"highlight_end":42}],"label":"private associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":794,"byte_end":888,"line_start":44,"line_end":44,"column_start":5,"column_end":99,"is_primary":false,"text":[{"text":"    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {","highlight_start":5,"highlight_end":99}],"label":"private associated function defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0624]\u001b[0m\u001b[0m\u001b[1m: associated function `new` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:10:39\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut driver = DriverProcesses::new(read_process, write_process);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate associated function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/driver.rs:44:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mprivate associated function defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `ReadOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":271,"byte_end":283,"line_start":10,"line_end":10,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"    let mut driver = DriverProcesses::new(read_process, write_process);","highlight_start":43,"highlight_end":55}],"label":"`ReadOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":136,"byte_end":150,"line_start":13,"line_end":13,"column_start":11,"column_end":25,"is_primary":false,"text":[{"text":"pub trait ReadOperations {","highlight_start":11,"highlight_end":25}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":166,"byte_end":170,"line_start":14,"line_end":14,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>;","highlight_start":14,"highlight_end":18}],"label":"...because method `read` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `read` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverRead` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:10:43\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut driver = DriverProcesses::new(read_process, write_process);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:14:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ReadOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `read` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `read` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverRead` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `WriteOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":285,"byte_end":298,"line_start":10,"line_end":10,"column_start":57,"column_end":70,"is_primary":true,"text":[{"text":"    let mut driver = DriverProcesses::new(read_process, write_process);","highlight_start":57,"highlight_end":70}],"label":"`WriteOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":221,"byte_end":236,"line_start":17,"line_end":17,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait WriteOperations {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":"...because method `write` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `write` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverWrite` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:10:57\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut driver = DriverProcesses::new(read_process, write_process);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait WriteOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `write` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `write` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverWrite` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`main` function is not allowed to be `async`","code":{"code":"E0752","explanation":"The entry point of the program was marked as `async`.\n\nErroneous code example:\n\n```compile_fail,E0752\nasync fn main() -> Result<(), ()> { // error!\n    Ok(())\n}\n```\n\n`fn main()` or the specified start function is not allowed to be `async`. Not\nhaving a correct async runtime library setup may cause this error. To fix it,\ndeclare the entry point without `async`:\n\n```\nfn main() -> Result<(), ()> { // ok!\n    Ok(())\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":110,"byte_end":125,"line_start":6,"line_end":6,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"async fn main() {","highlight_start":1,"highlight_end":16}],"label":"`main` function is not allowed to be `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0752]\u001b[0m\u001b[0m\u001b[1m: `main` function is not allowed to be `async`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:6:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0masync fn main() {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`main` function is not allowed to be `async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":421,"byte_end":428,"line_start":24,"line_end":25,"column_start":54,"column_end":6,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>{","highlight_start":54,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"expected `Result<Data, DriverError>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `Result<Data, DriverError>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:24:54\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m______________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Data, DriverError>`, found `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m:   expected enum `\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<Data, DriverError>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found unit type `\u001b[0m\u001b[0m\u001b[1m\u001b[35m()\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `NotInitialized` found for enum `DriverError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1488,"byte_end":1502,"line_start":68,"line_end":68,"column_start":55,"column_end":69,"is_primary":true,"text":[{"text":"        if !self.initialized{ return Err(DriverError::NotInitialized); }","highlight_start":55,"highlight_end":69}],"label":"variant or associated item not found in `DriverError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":41,"byte_end":57,"line_start":4,"line_end":4,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"enum DriverError {","highlight_start":1,"highlight_end":17}],"label":"variant or associated item `NotInitialized` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/driver.rs","byte_start":1488,"byte_end":1503,"line_start":68,"line_end":68,"column_start":55,"column_end":70,"is_primary":true,"text":[{"text":"        if !self.initialized{ return Err(DriverError::NotInitialized); }","highlight_start":55,"highlight_end":70}],"label":null,"suggested_replacement":"NotINitialized","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `NotInitialized` found for enum `DriverError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:68:55\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0menum DriverError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `NotInitialized` not found for this enum\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !self.initialized{ return Err(DriverError::NotInitialized); }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `DriverError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if !self.initialized{ return Err(DriverError::\u001b[0m\u001b[0m\u001b[38;5;10mNotINitialized\u001b[0m\u001b[0m; }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `ReadOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1605,"byte_end":1609,"line_start":71,"line_end":71,"column_start":27,"column_end":31,"is_primary":true,"text":[{"text":"        self.read_process.read().await","highlight_start":27,"highlight_end":31}],"label":"`ReadOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":136,"byte_end":150,"line_start":13,"line_end":13,"column_start":11,"column_end":25,"is_primary":false,"text":[{"text":"pub trait ReadOperations {","highlight_start":11,"highlight_end":25}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":166,"byte_end":170,"line_start":14,"line_end":14,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>;","highlight_start":14,"highlight_end":18}],"label":"...because method `read` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `read` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverRead` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:71:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.read_process.read().await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:14:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ReadOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `read` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `read` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverRead` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `ReadOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1587,"byte_end":1611,"line_start":71,"line_end":71,"column_start":9,"column_end":33,"is_primary":true,"text":[{"text":"        self.read_process.read().await","highlight_start":9,"highlight_end":33}],"label":"`ReadOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":136,"byte_end":150,"line_start":13,"line_end":13,"column_start":11,"column_end":25,"is_primary":false,"text":[{"text":"pub trait ReadOperations {","highlight_start":11,"highlight_end":25}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":166,"byte_end":170,"line_start":14,"line_end":14,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>;","highlight_start":14,"highlight_end":18}],"label":"...because method `read` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `read` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverRead` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:71:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.read_process.read().await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:14:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ReadOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `read` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `read` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverRead` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `NotInitialized` found for enum `DriverError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1750,"byte_end":1764,"line_start":75,"line_end":75,"column_start":55,"column_end":69,"is_primary":true,"text":[{"text":"        if !self.initialized{ return Err(DriverError::NotInitialized); }","highlight_start":55,"highlight_end":69}],"label":"variant or associated item not found in `DriverError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":41,"byte_end":57,"line_start":4,"line_end":4,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"enum DriverError {","highlight_start":1,"highlight_end":17}],"label":"variant or associated item `NotInitialized` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/driver.rs","byte_start":1750,"byte_end":1765,"line_start":75,"line_end":75,"column_start":55,"column_end":70,"is_primary":true,"text":[{"text":"        if !self.initialized{ return Err(DriverError::NotInitialized); }","highlight_start":55,"highlight_end":70}],"label":null,"suggested_replacement":"NotINitialized","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `NotInitialized` found for enum `DriverError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:75:55\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0menum DriverError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `NotInitialized` not found for this enum\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !self.initialized{ return Err(DriverError::NotInitialized); }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `DriverError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if !self.initialized{ return Err(DriverError::\u001b[0m\u001b[0m\u001b[38;5;10mNotINitialized\u001b[0m\u001b[0m; }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `WriteOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1869,"byte_end":1874,"line_start":78,"line_end":78,"column_start":28,"column_end":33,"is_primary":true,"text":[{"text":"        self.write_process.write().await","highlight_start":28,"highlight_end":33}],"label":"`WriteOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":221,"byte_end":236,"line_start":17,"line_end":17,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait WriteOperations {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":"...because method `write` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `write` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverWrite` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:78:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.write_process.write().await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait WriteOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `write` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `write` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverWrite` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `WriteOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1850,"byte_end":1876,"line_start":78,"line_end":78,"column_start":9,"column_end":35,"is_primary":true,"text":[{"text":"        self.write_process.write().await","highlight_start":9,"highlight_end":35}],"label":"`WriteOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":221,"byte_end":236,"line_start":17,"line_end":17,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait WriteOperations {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":"...because method `write` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `write` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverWrite` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:78:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.write_process.write().await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait WriteOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `write` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `write` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverWrite` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 1 argument but 0 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":1874,"byte_end":1876,"line_start":78,"line_end":78,"column_start":33,"column_end":35,"is_primary":false,"text":[{"text":"        self.write_process.write().await","highlight_start":33,"highlight_end":35}],"label":"argument #1 of type `Data` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":1869,"byte_end":1874,"line_start":78,"line_end":78,"column_start":28,"column_end":33,"is_primary":true,"text":[{"text":"        self.write_process.write().await","highlight_start":28,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src/driver.rs","byte_start":1874,"byte_end":1876,"line_start":78,"line_end":78,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"        self.write_process.write().await","highlight_start":33,"highlight_end":35}],"label":null,"suggested_replacement":"(/* Data */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this method takes 1 argument but 0 arguments were supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:78:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.write_process.write().await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument #1 of type `Data` is missing\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        self.write_process.write\u001b[0m\u001b[0m\u001b[38;5;10m(/* Data */)\u001b[0m\u001b[0m.await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `ReadOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":694,"byte_end":712,"line_start":39,"line_end":39,"column_start":27,"column_end":45,"is_primary":true,"text":[{"text":"    pub read_process: Box<dyn ReadOperations>,","highlight_start":27,"highlight_end":45}],"label":"`ReadOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":136,"byte_end":150,"line_start":13,"line_end":13,"column_start":11,"column_end":25,"is_primary":false,"text":[{"text":"pub trait ReadOperations {","highlight_start":11,"highlight_end":25}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":166,"byte_end":170,"line_start":14,"line_end":14,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>;","highlight_start":14,"highlight_end":18}],"label":"...because method `read` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `read` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverRead` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:39:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub read_process: Box<dyn ReadOperations>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:14:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ReadOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `read` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `read` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverRead` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `WriteOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":742,"byte_end":761,"line_start":40,"line_end":40,"column_start":28,"column_end":47,"is_primary":true,"text":[{"text":"    pub write_process: Box<dyn WriteOperations>,","highlight_start":28,"highlight_end":47}],"label":"`WriteOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":221,"byte_end":236,"line_start":17,"line_end":17,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait WriteOperations {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":"...because method `write` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `write` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverWrite` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:40:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub write_process: Box<dyn WriteOperations>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait WriteOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `write` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `write` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverWrite` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `ReadOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":819,"byte_end":837,"line_start":44,"line_end":44,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {","highlight_start":30,"highlight_end":48}],"label":"`ReadOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":136,"byte_end":150,"line_start":13,"line_end":13,"column_start":11,"column_end":25,"is_primary":false,"text":[{"text":"pub trait ReadOperations {","highlight_start":11,"highlight_end":25}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":166,"byte_end":170,"line_start":14,"line_end":14,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    async fn read(&self) -> Result<Data, DriverError>;","highlight_start":14,"highlight_end":18}],"label":"...because method `read` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `read` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverRead` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:44:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`ReadOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:14:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait ReadOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn read(&self) -> Result<Data, DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `read` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `read` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverRead` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `WriteOperations` cannot be made into an object","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"object-safe\" traits.\nAttempting to use a trait object type for a trait that is not object-safe will\ntrigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate object-safety follow, most of which relate\nto missing size information and vtable polymorphism arising from these aspects.\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not object-safe.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered object-safe.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they cannot\nbe made into an object.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is object safe!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"src/driver.rs","byte_start":859,"byte_end":878,"line_start":44,"line_end":44,"column_start":70,"column_end":89,"is_primary":true,"text":[{"text":"    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {","highlight_start":70,"highlight_end":89}],"label":"`WriteOperations` cannot be made into an object","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>","code":null,"level":"note","spans":[{"file_name":"src/driver.rs","byte_start":221,"byte_end":236,"line_start":17,"line_end":17,"column_start":11,"column_end":26,"is_primary":false,"text":[{"text":"pub trait WriteOperations {","highlight_start":11,"highlight_end":26}],"label":"this trait cannot be made into an object...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/driver.rs","byte_start":252,"byte_end":257,"line_start":18,"line_end":18,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    async fn write(&self, data:Data) -> Result<(), DriverError>;","highlight_start":14,"highlight_end":19}],"label":"...because method `write` is `async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider moving `write` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"only type `driver::DriverWrite` implements the trait, consider using it directly instead","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0038]\u001b[0m\u001b[0m\u001b[1m: the trait `WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:44:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(read_process: Box<dyn ReadOperations>, write_process: Box<dyn WriteOperations>) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`WriteOperations` cannot be made into an object\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/driver.rs:18:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait WriteOperations {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis trait cannot be made into an object...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn write(&self, data:Data) -> Result<(), DriverError>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m...because method `write` is `async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider moving `write` to another trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: only type `driver::DriverWrite` implements the trait, consider using it directly instead\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 19 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 19 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0038, E0061, E0308, E0423, E0432, E0599, E0624, E0752.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0038, E0061, E0308, E0423, E0432, E0599, E0624, E0752.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0038`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0038`.\u001b[0m\n"}
